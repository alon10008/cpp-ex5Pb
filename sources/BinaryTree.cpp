#include <iostream>
#include "BinaryTree.hpp"

using namespace ariel;
using namespace std;


/*template <typename T>
BinaryTree<T> BinaryTree<T>::add_root(const T&  t) {
    
    Node d{this->root.left, this->root.right, t};
    this->root = d;
    
}
template <typename T>
BinaryTree<T> ariel::BinaryTree<T>::add_left(const T& exist,const T& t) {

    return *this;

}
template <typename T>
BinaryTree<T> ariel::BinaryTree<T>::add_right(const T& exist,const T& t) {

    return *this;

}
template <typename T>
typename BinaryTree<T>::iterator_pre ariel::BinaryTree<T>::begin_preorder() {

    iterator_pre ip{nullptr};
    return ip;

}
template <typename T>
typename BinaryTree<T>::iterator_pre ariel::BinaryTree<T>::end_preorder() {

    iterator_pre ip{nullptr};
    return ip;

}
template <typename T>
typename BinaryTree<T>::iterator_in ariel::BinaryTree<T>::begin_inorder() {

    iterator_in ii{nullptr};
    return ii;

}
template <typename T>
typename BinaryTree<T>::iterator_in ariel::BinaryTree<T>::end_inorder() {

    iterator_in ii{nullptr};
    return ii;

}
template <typename T>
typename ariel::BinaryTree<T>::iterator_post ariel::BinaryTree<T>::begin_postorder() {

    iterator_post ip{nullptr};
    return ip;

}
template <typename T>
typename BinaryTree<T>::iterator_post ariel::BinaryTree<T>::end_postorder() {

    iterator_post ip{nullptr};
    return ip;

}
template <typename T>
typename BinaryTree<T>::iterator_pre ariel::BinaryTree<T>::begin() {

    iterator_pre ip{nullptr};
    return ip;

}
template <typename T>
typename BinaryTree<T>::iterator_pre ariel::BinaryTree<T>::end() {

    iterator_pre ip{nullptr};
    return ip;

}
template <typename T>
ostream& operator<<(ostream& os, BinaryTree<T> bt){

    os << "hello\n";
    return os;

}*/

